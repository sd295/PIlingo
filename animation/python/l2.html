<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amsterdam Canal & Tulips</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #87CEEB;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #333;
            font-family: 'Georgia', serif;
            font-size: 16px;
            font-weight: bold;
            pointer-events: none;
            background: rgba(255,255,255,0.7);
            padding: 5px 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="ui">The Netherlands: Canals & Windmills</div>
    <canvas id="nlCanvas"></canvas>

<script>
/**
 * NETHERLANDS SCENE (Amsterdam)
 * Features: Canal Houses, Windmill, Swaying Tulips, Bicycle, Reflections
 */

const canvas = document.getElementById('nlCanvas');
const ctx = canvas.getContext('2d');

let w, h;
let tick = 0;

// --- PALETTE ---
const COLORS = {
    skyTop: '#6EB1E1',
    skyBot: '#C4E0E5',
    bricks: ['#8B4513', '#A0522D', '#654321', '#800000', '#5D4037'],
    roofs: ['#2F4F4F', '#191970', '#333333'],
    tulips: ['#FF1493', '#FF4500', '#FFD700', '#DA70D6'], // Pink, Red, Gold, Orchid
    water: '#365d6e'
};

// --- RESIZE ---
function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// --- UTILS ---
const rand = (min, max) => Math.random() * (max - min) + min;
const randArr = (arr) => arr[Math.floor(Math.random() * arr.length)];

// --- CLASSES ---

class Cloud {
    constructor() {
        this.reset();
        this.x = rand(0, w); // Start anywhere
    }
    reset() {
        this.x = -150;
        this.y = rand(0, h * 0.4);
        this.speed = rand(0.2, 0.6);
        this.size = rand(40, 80);
        this.puffs = Math.floor(rand(3, 6));
    }
    update() {
        this.x += this.speed;
        if (this.x > w + 150) this.reset();
    }
    draw() {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.beginPath();
        for(let i=0; i<this.puffs; i++) {
            ctx.arc(this.x + (i*30), this.y + (i%2)*10, this.size, 0, Math.PI*2);
        }
        ctx.fill();
    }
}

class Windmill {
    constructor(x, y, scale) {
        this.x = x;
        this.y = y;
        this.scale = scale;
        this.angle = 0;
    }

    draw() {
        const s = this.scale;
        this.angle += 0.01;

        ctx.save();
        ctx.translate(this.x, this.y);

        // Body (Thatch/Wood)
        ctx.fillStyle = '#5D4037';
        ctx.beginPath();
        ctx.moveTo(-20*s, 0);
        ctx.lineTo(-10*s, -80*s); // Top Left
        ctx.lineTo(10*s, -80*s);  // Top Right
        ctx.lineTo(20*s, 0);      // Bottom Right
        ctx.fill();

        // Cap
        ctx.fillStyle = '#2f3a25';
        ctx.beginPath();
        ctx.arc(0, -80*s, 15*s, Math.PI, 0);
        ctx.fill();

        // Blades Center
        ctx.translate(0, -80*s);
        ctx.rotate(this.angle);

        // Draw 4 Blades
        ctx.fillStyle = '#333';
        for(let i=0; i<4; i++) {
            ctx.rotate(Math.PI/2);
            ctx.beginPath();
            ctx.rect(-2*s, 0, 4*s, 70*s); // Stick
            ctx.fill();
            
            // Cloth/Grid
            ctx.fillStyle = 'rgba(200,200,200,0.5)';
            ctx.fillRect(2*s, 10*s, 10*s, 50*s);
            ctx.strokeRect(2*s, 10*s, 10*s, 50*s);
        }

        ctx.restore();
    }
}

class Tulip {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.color = randArr(COLORS.tulips);
        this.height = rand(30, 50);
        this.swayOffset = rand(0, Math.PI);
    }

    draw() {
        // Wind Sway
        const sway = Math.sin(tick * 0.05 + this.swayOffset) * 5;

        // Stem
        ctx.strokeStyle = '#228B22';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.quadraticCurveTo(this.x + sway, this.y - this.height/2, this.x + sway, this.y - this.height);
        ctx.stroke();

        // Leaves
        ctx.fillStyle = '#32CD32';
        ctx.beginPath();
        ctx.ellipse(this.x, this.y - 10, 5, 15, -0.5 + (sway*0.05), 0, Math.PI*2);
        ctx.fill();

        // Flower Head
        ctx.fillStyle = this.color;
        const headX = this.x + sway;
        const headY = this.y - this.height;
        
        ctx.beginPath();
        ctx.moveTo(headX, headY);
        // Cup shape
        ctx.bezierCurveTo(headX - 10, headY - 15, headX - 10, headY - 25, headX, headY - 20); // Left petal
        ctx.bezierCurveTo(headX + 10, headY - 25, headX + 10, headY - 15, headX, headY); // Right petal
        ctx.fill();
    }
}

class House {
    constructor(x) {
        this.x = x;
        this.w = rand(40, 70);
        this.h = rand(120, 200); // Building height
        this.color = randArr(COLORS.bricks);
        this.roofType = Math.floor(rand(0, 3)); // 0: Step, 1: Bell, 2: Spout
        this.windows = [];
        
        // Generate windows
        const rows = Math.floor(this.h / 30);
        for(let i=1; i<rows; i++) {
            this.windows.push(i * 30);
        }
    }

    draw(groundY) {
        const topY = groundY - this.h;
        
        // Facade
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, topY, this.w, this.h);
        
        // Brick texture details (subtle)
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.fillRect(this.x + 5, topY, 2, this.h);
        ctx.fillRect(this.x + this.w - 7, topY, 2, this.h);

        // Roof / Gable
        ctx.fillStyle = '#222'; // Dark trim
        
        if (this.roofType === 0) { // Stepped Gable
            let stepW = this.w / 6;
            let stepH = 10;
            for(let i=0; i<3; i++) {
                ctx.fillRect(this.x + (i*stepW), topY - ((i+1)*stepH), this.w - (i*2*stepW), stepH);
            }
            ctx.fillRect(this.x + this.w/2 - 2, topY - 40, 4, 15); // Pinnacle
        } else if (this.roofType === 1) { // Bell Gable
            ctx.beginPath();
            ctx.moveTo(this.x, topY);
            ctx.bezierCurveTo(this.x, topY - 30, this.x + this.w/2, topY - 50, this.x + this.w, topY);
            ctx.fill();
        } else { // Triangular
            ctx.beginPath();
            ctx.moveTo(this.x, topY);
            ctx.lineTo(this.x + this.w/2, topY - 30);
            ctx.lineTo(this.x + this.w, topY);
            ctx.fill();
        }

        // Windows (White Frames)
        ctx.fillStyle = '#FFF';
        this.windows.forEach(wy => {
            const winW = this.w * 0.6;
            const winX = this.x + (this.w - winW)/2;
            ctx.fillRect(winX, groundY - wy, winW, 20);
            
            // Glass
            ctx.fillStyle = '#4a5d68'; // Dark blue glass
            ctx.fillRect(winX + 2, groundY - wy + 2, winW - 4, 16);
            
            // Frame cross
            ctx.fillStyle = '#FFF';
            ctx.fillRect(winX + winW/2 - 1, groundY - wy, 2, 20);
        });

        // Shop/Door at bottom
        ctx.fillStyle = '#1a2226';
        ctx.fillRect(this.x + 10, groundY - 40, this.w - 20, 40);
    }
}

class Bicycle {
    constructor() {
        this.x = -50;
        this.y = 0; // Set in draw
        this.speed = 1.5;
    }

    update() {
        this.x += this.speed;
        if (this.x > w + 50) this.x = -50;
    }

    draw(bridgeY) {
        const y = bridgeY - 15;
        const wheelSize = 10;

        ctx.save();
        ctx.translate(this.x, y);

        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;

        // Wheels (Rotating spokes)
        [0, 40].forEach(ox => {
            ctx.beginPath();
            ctx.arc(ox, 0, wheelSize, 0, Math.PI*2);
            ctx.stroke();
            
            // Spokes
            ctx.save();
            ctx.translate(ox, 0);
            ctx.rotate(tick * 0.1);
            ctx.beginPath();
            ctx.moveTo(0, -wheelSize); ctx.lineTo(0, wheelSize);
            ctx.moveTo(-wheelSize, 0); ctx.lineTo(wheelSize, 0);
            ctx.stroke();
            ctx.restore();
        });

        // Frame
        ctx.beginPath();
        ctx.moveTo(0, 0); // Rear wheel
        ctx.lineTo(15, -15); // Seat post bottom
        ctx.lineTo(35, -15); // Handlebar post bottom
        ctx.lineTo(40, 0); // Front wheel
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(15, -15);
        ctx.lineTo(13, -25); // Seat post
        ctx.moveTo(35, -15);
        ctx.lineTo(33, -28); // Handlebars
        ctx.stroke();

        // Seat & Handles
        ctx.fillStyle = '#000';
        ctx.fillRect(10, -26, 8, 3); // Seat
        ctx.beginPath(); ctx.arc(33, -28, 2, 0, Math.PI*2); ctx.fill();

        // Rider (Simplified Stickman)
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(14, -25); // Butt
        ctx.lineTo(15, -40); // Back
        ctx.lineTo(30, -30); // Arms to bars
        ctx.stroke();
        ctx.beginPath(); ctx.arc(15, -45, 4, 0, Math.PI*2); ctx.fill(); // Head

        ctx.restore();
    }
}

// --- GENERATION ---

const clouds = Array.from({length: 5}, () => new Cloud());
let houses = [];
let tulips = [];
const windmill = new Windmill(100, 0, 2.5); // Y set later
const bike = new Bicycle();

function init() {
    houses = [];
    let cx = 0;
    // Generate row of houses
    while(cx < w) {
        const h = new House(cx);
        houses.push(h);
        cx += h.w; // Touch each other
    }

    // Generate Tulips foreground
    tulips = [];
    for(let i=0; i<w; i+=15) {
        tulips.push(new Tulip(i + rand(-5, 5), h));
    }
}

window.addEventListener('resize', () => {
    resize();
    init();
});
init();

// --- ANIMATION ---

function animate() {
    ctx.clearRect(0, 0, w, h);

    // Sky Gradient
    const grad = ctx.createLinearGradient(0, 0, 0, h);
    grad.addColorStop(0, COLORS.skyTop);
    grad.addColorStop(1, COLORS.skyBot);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    // Clouds
    clouds.forEach(c => { c.update(); c.draw(); });

    // Ground Level
    const groundY = h * 0.65;
    
    // Draw Windmill (Background)
    windmill.y = groundY;
    windmill.x = w * 0.8; // Position right side
    windmill.draw();

    // Draw Houses
    houses.forEach(house => house.draw(groundY));

    // Bridge
    const bridgeY = groundY + 20;
    ctx.fillStyle = '#555'; // Stone color
    ctx.fillRect(0, groundY, w, 20); // Road
    // Arch
    ctx.fillStyle = COLORS.water; // Cut out arch
    ctx.beginPath();
    ctx.arc(w/2, groundY + 20, 60, Math.PI, 0);
    ctx.fill();
    // Bridge Railing
    ctx.strokeStyle = '#222';
    ctx.beginPath();
    ctx.moveTo(0, groundY);
    ctx.lineTo(w, groundY);
    ctx.stroke();

    // Water
    const waterY = groundY + 20;
    ctx.fillStyle = COLORS.water;
    ctx.fillRect(0, waterY, w, h - waterY);

    // Reflections (The House Reflection Logic)
    ctx.save();
    ctx.globalAlpha = 0.3;
    // Clip to water area
    ctx.beginPath();
    ctx.rect(0, waterY, w, h - waterY);
    ctx.clip();
    
    // Invert and draw houses
    ctx.translate(0, waterY * 2 - 30); // Mirror position adjustment
    ctx.scale(1, -1);
    
    houses.forEach((house, i) => {
        // Add wave distortion to x
        const wave = Math.sin(tick * 0.02 + i) * 3;
        ctx.translate(wave, 0);
        house.draw(groundY);
        ctx.translate(-wave, 0);
    });
    ctx.restore();

    // Water Sparkles/Waves
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    for(let i=0; i<10; i++) {
        const rx = rand(0, w);
        const ry = rand(waterY, h);
        const rw = rand(10, 50);
        ctx.fillRect(rx + Math.sin(tick*0.05)*10, ry, rw, 2);
    }

    // Bicycle Animation (Crossing bridge)
    bike.draw(groundY);
    bike.update();

    // Tulips (Foreground)
    tulips.forEach(t => t.draw());

    tick++;
    requestAnimationFrame(animate);
}

animate();

</script>
</body>
</html>
